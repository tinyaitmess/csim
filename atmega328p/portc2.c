/* Generated by gliss-csim (125/03/24 12:37:42) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _DDRC	__inst->DDRC
#	define _PORTC	__inst->PORTC

#	define PIN_BASE	0
#	define _PIN	__inst->PIN
#	define PIN_PORT	&ports[PIN_BASE]
#		define PIN_SET(i, x)	\
			{ \
				if(_PIN[i] != x) { \
					_PIN[i] = x; \
					csim_send_digital(inst, PIN_PORT + i, _PIN[i]); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  portc2_inst_t {
    csim_iocomp_t inst;
			uint8_t DDRC;
			uint8_t PORTC;

			uint8_t PIN[8];
;
}  portc2_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_PIN(csim_inst_t *inst);


/* pre-definitiion of event update functions */


/* pre-definitiion of event trigger functions */


static void on_update_all(csim_inst_t *inst) {
		on_update_PIN(inst);
	
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  portc2_reset(csim_inst_t *inst) {
    portc2_inst_t * portc2_inst = ( portc2_inst_t *)inst;
	portc2_inst -> DDRC = 0;
	portc2_inst -> PORTC = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void portc2_construct(csim_inst_t *inst, csim_confs_t confs) {
    portc2_inst_t * portc2_inst = ( portc2_inst_t *)inst;
    portc2_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void portc2_destruct(csim_inst_t *inst) {
}


/* DDRC register functions */

static void name_DDRC(csim_inst_t *inst, int num, char *__buffer, int size) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port C Data Direction Register");

}


static void display_DDRC(csim_inst_t *inst, int num, char *__buffer, int size) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->DDRC);;
}

static csim_word_t read_DDRC(csim_inst_t *inst, int num) {
		portc2_inst_t *__inst = (portc2_inst_t *)inst;
				return __inst->DDRC;
}
 
static csim_word_t get_DDRC(csim_inst_t *inst, int num) {
		portc2_inst_t *__inst = (portc2_inst_t *)inst;
			return __inst->DDRC;
}
 
static void set_DDRC(csim_inst_t *inst, int num, csim_word_t val) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
		if(__inst->DDRC != val) {
			__inst->DDRC = val;
			on_update_all(inst);
		}
	
}

static void write_DDRC(csim_inst_t *inst, int num, csim_word_t val) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
	set_DDRC(inst, num, val);

		;
		on_update_all(inst);
	
}

/* PORTC register functions */

static void name_PORTC(csim_inst_t *inst, int num, char *__buffer, int size) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port C Data Register");

}


static void display_PORTC(csim_inst_t *inst, int num, char *__buffer, int size) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->PORTC);;
}

static csim_word_t read_PORTC(csim_inst_t *inst, int num) {
		portc2_inst_t *__inst = (portc2_inst_t *)inst;
				return __inst->PORTC;
}
 
static csim_word_t get_PORTC(csim_inst_t *inst, int num) {
		portc2_inst_t *__inst = (portc2_inst_t *)inst;
			return __inst->PORTC;
}
 
static void set_PORTC(csim_inst_t *inst, int num, csim_word_t val) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
		if(__inst->PORTC != val) {
			__inst->PORTC = val;
			on_update_all(inst);
		}
	
}

static void write_PORTC(csim_inst_t *inst, int num, csim_word_t val) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
	set_PORTC(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"DDRC",		// name
		0x27,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_DDRC,
		display_DDRC,
		read_DDRC,
		write_DDRC,
		get_DDRC,
		set_DDRC
	},
	{
		"PORTC",		// name
		0x28,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_PORTC,
		display_PORTC,
		read_PORTC,
		write_PORTC,
		get_PORTC,
		set_PORTC
	},

};


/* predeclaration of port-functions */
static void on_input_PIN(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
				{
					"PIN0",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN1",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN2",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN3",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN4",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN5",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN6",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN7",
					CSIM_DIGITAL,
					on_input_PIN
				},


};


/* PIN port functions */

static void on_input_PIN(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	portc2_inst_t *__inst = (portc2_inst_t *)port->inst;
	uint8_t PIN = __inst->PIN;
	int ____INDEX = port->port - (ports + PIN_BASE);
	if (type == CSIM_DIGITAL)
		PIN = val.digital;
	if (type == CSIM_ANALOG)
		PIN = val.analog;
	if (type == CSIM_CLOCK)
		PIN = val.clock;
	if (type == CSIM_SERIAL)
		PIN = val.serial;
	
	
	
	if((((uint32_t)(_field8_generic(_DDRC, ____INDEX, ____INDEX, 1 ))) == 0)) {
		_PORTC = _set_field8_generic(_PORTC, ((uint8_t)(_PIN[____INDEX])), ____INDEX, ____INDEX, 1);
	}

}

static void on_update_PIN(csim_inst_t *inst) {
	portc2_inst_t *__inst = (portc2_inst_t *)inst;
	uint32_t __gliss_0_i;
	for(__gliss_0_i = 0; __gliss_0_i != 6+ 1; __gliss_0_i++) {
		if((((uint32_t)(_field8_generic(_DDRC, __gliss_0_i, __gliss_0_i, 1 ))) == 1)) {
			PIN_SET(__gliss_0_i, ((uint8_t)(_field8_generic(_PORTC, __gliss_0_i, __gliss_0_i, 1 ))));
		}
	}

}






static int portc2_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void portc2_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  portc2_component = {
	{
    "portc2",
    CSIM_IO,
    0,					// version
    regs,				// registers
    2 ,	// register count
    ports,				// ports
    8,		// port count
    sizeof(portc2_inst_t),
    portc2_construct,
    portc2_destruct,
    portc2_reset
	},
	portc2_display,
	portc2_on_key
};

