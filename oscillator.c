/* Generated by gliss-csim (125/03/26 13:55:55) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _OSC_ENABLED	__inst->OSC_ENABLED
#	define _OSC_READY	__inst->OSC_READY
#	define _XTAL_CTRL	__inst->XTAL_CTRL
#	define _STARTUP_DELAY	__inst->STARTUP_DELAY
#	define _CURRENT_TIME	__inst->CURRENT_TIME

#	define XTAL2_BASE	0
#	define _XTAL2	__inst->XTAL2
#	define XTAL2_PORT	&ports[XTAL2_BASE]
#		define XTAL2_SET(x)	\
			{ \
				if(x != _XTAL2) { \ 
					_XTAL2 = x; \
					csim_send_digital(inst, XTAL2_PORT, _XTAL2); \
				} \
			}
#	define XTAL1_BASE	1
#	define _XTAL1	__inst->XTAL1
#	define XTAL1_PORT	&ports[XTAL1_BASE]
#		define XTAL1_SET(x)	\
			{ \
				if(x != _XTAL1) { \ 
					_XTAL1 = x; \
					csim_send_digital(inst, XTAL1_PORT, _XTAL1); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  oscillator_inst_t {
    csim_iocomp_t inst;
			uint8_t OSC_ENABLED;
			uint8_t OSC_READY;
			uint8_t XTAL_CTRL;
			uint16_t STARTUP_DELAY;
			uint16_t CURRENT_TIME;

			uint8_t XTAL2;
			uint8_t XTAL1;
;
}  oscillator_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_XTAL2(csim_inst_t *inst);
	static void on_update_XTAL1(csim_inst_t *inst);


/* pre-definitiion of event update functions */
	static void on_update_startup_sequence(csim_inst_t *inst);


/* pre-definitiion of event trigger functions */
	static void on_trigger_startup_sequence(csim_evt_t *evt);


static void on_update_all(csim_inst_t *inst) {
		on_update_XTAL2(inst);
		on_update_XTAL1(inst);
	
		on_update_startup_sequence(inst);
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  oscillator_reset(csim_inst_t *inst) {
    oscillator_inst_t * oscillator_inst = ( oscillator_inst_t *)inst;
	oscillator_inst -> OSC_ENABLED = 0;
	oscillator_inst -> OSC_READY = 0;
	oscillator_inst -> XTAL_CTRL = 0;
	oscillator_inst -> STARTUP_DELAY = 1000;
	oscillator_inst -> CURRENT_TIME = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void oscillator_construct(csim_inst_t *inst, csim_confs_t confs) {
    oscillator_inst_t * oscillator_inst = ( oscillator_inst_t *)inst;
    oscillator_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void oscillator_destruct(csim_inst_t *inst) {
}


/* OSC_READY register functions */

static void name_OSC_READY(csim_inst_t *inst, int num, char *__buffer, int size) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
		__buffer += sprintf(__buffer, "Oscillator Ready Flag");

}


static void display_OSC_READY(csim_inst_t *inst, int num, char *__buffer, int size) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OSC_READY);;
}

static csim_word_t read_OSC_READY(csim_inst_t *inst, int num) {
		oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
				return __inst->OSC_READY;
}
 
static csim_word_t get_OSC_READY(csim_inst_t *inst, int num) {
		oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
			return __inst->OSC_READY;
}
 
static void set_OSC_READY(csim_inst_t *inst, int num, csim_word_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
		if(__inst->OSC_READY != val) {
			__inst->OSC_READY = val;
			on_update_all(inst);
		}
	
}

static void write_OSC_READY(csim_inst_t *inst, int num, csim_word_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
	set_OSC_READY(inst, num, val);

		;
		on_update_all(inst);
	
}

/* XTAL_CTRL register functions */

static void name_XTAL_CTRL(csim_inst_t *inst, int num, char *__buffer, int size) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
		__buffer += sprintf(__buffer, "Oscillator Control Register");

}


static void display_XTAL_CTRL(csim_inst_t *inst, int num, char *__buffer, int size) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->XTAL_CTRL);;
}

static csim_word_t read_XTAL_CTRL(csim_inst_t *inst, int num) {
		oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
				return __inst->XTAL_CTRL;
}
 
static csim_word_t get_XTAL_CTRL(csim_inst_t *inst, int num) {
		oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
			return __inst->XTAL_CTRL;
}
 
static void set_XTAL_CTRL(csim_inst_t *inst, int num, csim_word_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
		if(__inst->XTAL_CTRL != val) {
			__inst->XTAL_CTRL = val;
			on_update_all(inst);
		}
	
}

static void write_XTAL_CTRL(csim_inst_t *inst, int num, csim_word_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;
	set_XTAL_CTRL(inst, num, val);

			if((((uint32_t)(_bit8(_XTAL_CTRL, 7))) == 1)) {
		_OSC_ENABLED = ((uint8_t)(1));
		_CURRENT_TIME = ((uint16_t)(0));
		csim_evt_t *startup_sequence = malloc(sizeof(csim_evt_t));
			startup_sequence->date = __now +1;
			startup_sequence->inst = inst;
			startup_sequence->trigger = on_trigger_startup_sequence;
			csim_record_event(inst -> board, startup_sequence);
	}
	else {
		_OSC_ENABLED = ((uint8_t)(0));
		_OSC_READY = ((uint8_t)(0));
	}
;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"OSC_ENABLED",		// name
		0x70,		// offset
		0,		// size
		1,		// count
		0,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},
	{
		"OSC_READY",		// name
		0x71,		// offset
		0,		// size
		1,		// count
		0,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OSC_READY,
		display_OSC_READY,
		read_OSC_READY,
		write_OSC_READY,
		get_OSC_READY,
		set_OSC_READY
	},
	{
		"XTAL_CTRL",		// name
		0x40,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_XTAL_CTRL,
		display_XTAL_CTRL,
		read_XTAL_CTRL,
		write_XTAL_CTRL,
		get_XTAL_CTRL,
		set_XTAL_CTRL
	},
	{
		"STARTUP_DELAY",		// name
		0x72,		// offset
		2,		// size
		1,		// count
		2,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},
	{
		"CURRENT_TIME",		// name
		0x73,		// offset
		2,		// size
		1,		// count
		2,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},

};


/* predeclaration of port-functions */
static void on_input_XTAL2(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);
static void on_input_XTAL1(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
			{
				"XTAL2",
				CSIM_DIGITAL,
				on_input_XTAL2
			},
			{
				"XTAL1",
				CSIM_DIGITAL,
				on_input_XTAL1
			},

};


/* XTAL2 port functions */

static void on_input_XTAL2(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)port->inst;
	uint8_t XTAL2 = __inst->XTAL2;
	int ____INDEX = port->port - (ports + XTAL2_BASE);
	if (type == CSIM_DIGITAL)
		XTAL2 = val.digital;
	if (type == CSIM_ANALOG)
		XTAL2 = val.analog;
	if (type == CSIM_CLOCK)
		XTAL2 = val.clock;
	if (type == CSIM_SERIAL)
		XTAL2 = val.serial;
	
	
	

}

static void on_update_XTAL2(csim_inst_t *inst) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;

}

/* XTAL1 port functions */

static void on_input_XTAL1(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)port->inst;
	uint8_t XTAL1 = __inst->XTAL1;
	int ____INDEX = port->port - (ports + XTAL1_BASE);
	if (type == CSIM_DIGITAL)
		XTAL1 = val.digital;
	if (type == CSIM_ANALOG)
		XTAL1 = val.analog;
	if (type == CSIM_CLOCK)
		XTAL1 = val.clock;
	if (type == CSIM_SERIAL)
		XTAL1 = val.serial;
	
	
	

}

static void on_update_XTAL1(csim_inst_t *inst) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;

}



/*startup_sequence event functions */

static void on_update_startup_sequence(csim_inst_t *inst) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)inst;

	
}

static void on_trigger_startup_sequence(csim_evt_t *evt) {
	oscillator_inst_t *__inst = (oscillator_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		if((((uint32_t)(_OSC_ENABLED)) == 1)) {
		if((_CURRENT_TIME >= _STARTUP_DELAY)) {
			_OSC_READY = ((uint8_t)(1));
			XTAL1_SET(((uint8_t)(1)));
			XTAL2_SET(((uint8_t)(1)));
		}
		else {
			_CURRENT_TIME = ((uint16_t)((((uint32_t)(_CURRENT_TIME)) + 1)));
			csim_evt_t *startup_sequence = malloc(sizeof(csim_evt_t));
			startup_sequence->date = __now +1;
			startup_sequence->inst = inst;
			startup_sequence->trigger = on_trigger_startup_sequence;
			csim_record_event(inst -> board, startup_sequence);
		}
	}

}




static int oscillator_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void oscillator_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  oscillator_component = {
	{
    "oscillator",
    CSIM_IO,
    0,					// version
    regs,				// registers
    5 ,	// register count
    ports,				// ports
    2,		// port count
    sizeof(oscillator_inst_t),
    oscillator_construct,
    oscillator_destruct,
    oscillator_reset
	},
	oscillator_display,
	oscillator_on_key
};

