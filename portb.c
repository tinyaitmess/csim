/* Generated by gliss-csim (125/03/23 11:07:47) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _DDRB	__inst->DDRB
#	define _PORTB	__inst->PORTB

#	define PORTB_PINS_BASE	0
#	define _PORTB_PINS	__inst->PORTB_PINS
#	define PORTB_PINS_PORT	&ports[PORTB_PINS_BASE]
#		define PORTB_PINS_SET(i, x)	\
			{ \
				if(_PORTB_PINS[i] != x) { \
					_PORTB_PINS[i] = x; \
					csim_send_digital(inst, PORTB_PINS_PORT + i, _PORTB_PINS[i]); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  portb_inst_t {
    csim_iocomp_t inst;
			uint8_t DDRB;
			uint8_t PORTB;

			uint8_t PORTB_PINS[8];
;
}  portb_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_PORTB_PINS(csim_inst_t *inst);


/* pre-definitiion of event update functions */


/* pre-definitiion of event trigger functions */


static void on_update_all(csim_inst_t *inst) {
		on_update_PORTB_PINS(inst);
	
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  portb_reset(csim_inst_t *inst) {
    portb_inst_t * portb_inst = ( portb_inst_t *)inst;
	portb_inst -> DDRB = 0;
	portb_inst -> PORTB = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void portb_construct(csim_inst_t *inst, csim_confs_t confs) {
    portb_inst_t * portb_inst = ( portb_inst_t *)inst;
    portb_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void portb_destruct(csim_inst_t *inst) {
}


/* DDRB register functions */

static void name_DDRB(csim_inst_t *inst, int num, char *__buffer, int size) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port B Data Direction Register");

}


static void display_DDRB(csim_inst_t *inst, int num, char *__buffer, int size) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->DDRB);;
}

static csim_word_t read_DDRB(csim_inst_t *inst, int num) {
		portb_inst_t *__inst = (portb_inst_t *)inst;
				return __inst->DDRB;
}
 
static csim_word_t get_DDRB(csim_inst_t *inst, int num) {
		portb_inst_t *__inst = (portb_inst_t *)inst;
			return __inst->DDRB;
}
 
static void set_DDRB(csim_inst_t *inst, int num, csim_word_t val) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
		if(__inst->DDRB != val) {
			__inst->DDRB = val;
			on_update_all(inst);
		}
	
}

static void write_DDRB(csim_inst_t *inst, int num, csim_word_t val) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
	set_DDRB(inst, num, val);

		;
		on_update_all(inst);
	
}

/* PORTB register functions */

static void name_PORTB(csim_inst_t *inst, int num, char *__buffer, int size) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port B Data Register");

}


static void display_PORTB(csim_inst_t *inst, int num, char *__buffer, int size) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->PORTB);;
}

static csim_word_t read_PORTB(csim_inst_t *inst, int num) {
		portb_inst_t *__inst = (portb_inst_t *)inst;
				return __inst->PORTB;
}
 
static csim_word_t get_PORTB(csim_inst_t *inst, int num) {
		portb_inst_t *__inst = (portb_inst_t *)inst;
			return __inst->PORTB;
}
 
static void set_PORTB(csim_inst_t *inst, int num, csim_word_t val) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
		if(__inst->PORTB != val) {
			__inst->PORTB = val;
			on_update_all(inst);
		}
	
}

static void write_PORTB(csim_inst_t *inst, int num, csim_word_t val) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
	set_PORTB(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"DDRB",		// name
		0x24,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_DDRB,
		display_DDRB,
		read_DDRB,
		write_DDRB,
		get_DDRB,
		set_DDRB
	},
	{
		"PORTB",		// name
		0x25,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_PORTB,
		display_PORTB,
		read_PORTB,
		write_PORTB,
		get_PORTB,
		set_PORTB
	},

};


/* predeclaration of port-functions */
static void on_input_PORTB_PINS(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
				{
					"PORTB_PINS0",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS1",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS2",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS3",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS4",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS5",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS6",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},
				{
					"PORTB_PINS7",
					CSIM_DIGITAL,
					on_input_PORTB_PINS
				},


};


/* PORTB_PINS port functions */

static void on_input_PORTB_PINS(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	portb_inst_t *__inst = (portb_inst_t *)port->inst;
	uint8_t PORTB_PINS = __inst->PORTB_PINS;
	int ____INDEX = port->port - (ports + PORTB_PINS_BASE);
	if (type == CSIM_DIGITAL)
		PORTB_PINS = val.digital;
	if (type == CSIM_ANALOG)
		PORTB_PINS = val.analog;
	if (type == CSIM_CLOCK)
		PORTB_PINS = val.clock;
	if (type == CSIM_SERIAL)
		PORTB_PINS = val.serial;
	
	
	
	if((((uint32_t)(_field8_generic(_DDRB, ____INDEX, ____INDEX, 1 ))) == 0)) {
		_PORTB = _set_field8_generic(_PORTB, ((uint8_t)(_PORTB_PINS[____INDEX])), ____INDEX, ____INDEX, 1);
	}

}

static void on_update_PORTB_PINS(csim_inst_t *inst) {
	portb_inst_t *__inst = (portb_inst_t *)inst;
	uint32_t __gliss_0_i;
	for(__gliss_0_i = 0; __gliss_0_i != 7+ 1; __gliss_0_i++) {
		if((((uint32_t)(_field8_generic(_DDRB, __gliss_0_i, __gliss_0_i, 1 ))) == 1)) {
			PORTB_PINS_SET(__gliss_0_i, ((uint8_t)(_field8_generic(_PORTB, __gliss_0_i, __gliss_0_i, 1 ))));
		}
	}

}






static int portb_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void portb_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  portb_component = {
	{
    "portb",
    CSIM_IO,
    0,					// version
    regs,				// registers
    2 ,	// register count
    ports,				// ports
    8,		// port count
    sizeof(portb_inst_t),
    portb_construct,
    portb_destruct,
    portb_reset
	},
	portb_display,
	portb_on_key
};

