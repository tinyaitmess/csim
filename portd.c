/* Generated by gliss-csim (125/03/22 17:10:45) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _PORTD	__inst->PORTD
#	define _DDRD	__inst->DDRD

#	define PIN_BASE	0
#	define _PIN	__inst->PIN
#	define PIN_PORT	&ports[PIN_BASE]
#		define PIN_SET(i, x)	\
			{ \
				if(_PIN[i] != x) { \
					_PIN[i] = x; \
					csim_send_digital(inst, PIN_PORT + i, _PIN[i]); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  portd_inst_t {
    csim_iocomp_t inst;
			uint8_t PORTD;
			uint8_t DDRD;

			uint8_t PIN[8];
;
}  portd_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_PIN(csim_inst_t *inst);


/* pre-definitiion of event update functions */


/* pre-definitiion of event trigger functions */


static void on_update_all(csim_inst_t *inst) {
		on_update_PIN(inst);
	
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  portd_reset(csim_inst_t *inst) {
    portd_inst_t * portd_inst = ( portd_inst_t *)inst;
	portd_inst -> PORTD = 0;
	portd_inst -> DDRD = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void portd_construct(csim_inst_t *inst, csim_confs_t confs) {
    portd_inst_t * portd_inst = ( portd_inst_t *)inst;
    portd_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void portd_destruct(csim_inst_t *inst) {
}


/* PORTD register functions */

static void name_PORTD(csim_inst_t *inst, int num, char *__buffer, int size) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port D Data Register");

}


static void display_PORTD(csim_inst_t *inst, int num, char *__buffer, int size) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->PORTD);;
}

static csim_word_t read_PORTD(csim_inst_t *inst, int num) {
		portd_inst_t *__inst = (portd_inst_t *)inst;
				return __inst->PORTD;
}
 
static csim_word_t get_PORTD(csim_inst_t *inst, int num) {
		portd_inst_t *__inst = (portd_inst_t *)inst;
			return __inst->PORTD;
}
 
static void set_PORTD(csim_inst_t *inst, int num, csim_word_t val) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
		if(__inst->PORTD != val) {
			__inst->PORTD = val;
			on_update_all(inst);
		}
	
}

static void write_PORTD(csim_inst_t *inst, int num, csim_word_t val) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
	set_PORTD(inst, num, val);

		;
		on_update_all(inst);
	
}

/* DDRD register functions */

static void name_DDRD(csim_inst_t *inst, int num, char *__buffer, int size) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
		__buffer += sprintf(__buffer, "Port D Data Direction Register");

}


static void display_DDRD(csim_inst_t *inst, int num, char *__buffer, int size) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->DDRD);;
}

static csim_word_t read_DDRD(csim_inst_t *inst, int num) {
		portd_inst_t *__inst = (portd_inst_t *)inst;
				return __inst->DDRD;
}
 
static csim_word_t get_DDRD(csim_inst_t *inst, int num) {
		portd_inst_t *__inst = (portd_inst_t *)inst;
			return __inst->DDRD;
}
 
static void set_DDRD(csim_inst_t *inst, int num, csim_word_t val) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
		if(__inst->DDRD != val) {
			__inst->DDRD = val;
			on_update_all(inst);
		}
	
}

static void write_DDRD(csim_inst_t *inst, int num, csim_word_t val) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
	set_DDRD(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"PORTD",		// name
		0x2b,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_PORTD,
		display_PORTD,
		read_PORTD,
		write_PORTD,
		get_PORTD,
		set_PORTD
	},
	{
		"DDRD",		// name
		0x2a,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_DDRD,
		display_DDRD,
		read_DDRD,
		write_DDRD,
		get_DDRD,
		set_DDRD
	},

};


/* predeclaration of port-functions */
static void on_input_PIN(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
				{
					"PIN0",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN1",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN2",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN3",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN4",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN5",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN6",
					CSIM_DIGITAL,
					on_input_PIN
				},
				{
					"PIN7",
					CSIM_DIGITAL,
					on_input_PIN
				},


};


/* PIN port functions */

static void on_input_PIN(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	portd_inst_t *__inst = (portd_inst_t *)port->inst;
	uint8_t PIN = __inst->PIN;
	int ____INDEX = port->port - (ports + PIN_BASE);
	if (type == CSIM_DIGITAL)
		PIN = val.digital;
	if (type == CSIM_ANALOG)
		PIN = val.analog;
	if (type == CSIM_CLOCK)
		PIN = val.clock;
	if (type == CSIM_SERIAL)
		PIN = val.serial;
	
	
	
	if((((uint32_t)(_field8_generic(_DDRD, ____INDEX, ____INDEX, 1 ))) == 0)) {
		_PORTD = _set_field8_generic(_PORTD, ((uint8_t)(_PIN[____INDEX])), ____INDEX, ____INDEX, 1);
	}

}

static void on_update_PIN(csim_inst_t *inst) {
	portd_inst_t *__inst = (portd_inst_t *)inst;
	uint32_t __gliss_0_i;
	for(__gliss_0_i = 0; __gliss_0_i != 7+ 1; __gliss_0_i++) {
		if((((uint32_t)(_field8_generic(_DDRD, __gliss_0_i, __gliss_0_i, 1 ))) == 1)) {
			PIN_SET(__gliss_0_i, ((uint8_t)(_field8_generic(_PORTD, __gliss_0_i, __gliss_0_i, 1 ))));
		}
	}

}






static int portd_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void portd_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  portd_component = {
	{
    "portd",
    CSIM_IO,
    0,					// version
    regs,				// registers
    2 ,	// register count
    ports,				// ports
    8,		// port count
    sizeof(portd_inst_t),
    portd_construct,
    portd_destruct,
    portd_reset
	},
	portd_display,
	portd_on_key
};

