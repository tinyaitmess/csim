/* Generated by gliss-csim (125/03/25 22:05:28) copyright (c) 2024 IRIT - UPS */

#include "csim-rt.h"
#include "csim.h"
#include <stdio.h>
#include <stdlib.h>

#define ____COMP_NUM (inst->number)
#define _TCCR1A __inst->TCCR1A
#define _CLK __inst->CLK
#define _OC1A __inst->OC1A
#define _ICR1L __inst->ICR1L
#define _ICR1H __inst->ICR1H
#define _TIMSK1 __inst->TIMSK1
#define _TCCR1B __inst->TCCR1B
#define _TCNT1L __inst->TCNT1L
#define _TIFR1 __inst->TIFR1
#define _OCR1BH __inst->OCR1BH
#define _TCCR1C __inst->TCCR1C
#define _OCR1BL __inst->OCR1BL
#define _OCR1AL __inst->OCR1AL
#define _TCNT1H __inst->TCNT1H
#define _OCR1AH __inst->OCR1AH

#define __now inst->board->date

/**
 * Instance definition.
 */
typedef struct tc16bit1_inst_t {
    csim_iocomp_t inst;
    uint8_t TCCR1A;
    uint8_t CLK;
    uint8_t OC1A;
    uint8_t ICR1L;
    uint8_t ICR1H;
    uint8_t TIMSK1;
    uint8_t TCCR1B;
    uint8_t TCNT1L;
    uint8_t TIFR1;
    uint8_t OCR1BH;
    uint8_t TCCR1C;
    uint8_t OCR1BL;
    uint8_t OCR1AL;
    uint8_t TCNT1H;
    uint8_t OCR1AH;

    ;
} tc16bit1_inst_t;

/* pre-definitiion of port update functions */

/* pre-definitiion of event update functions */
static void on_update_Reset(csim_inst_t *inst);
static void on_update_Update(csim_inst_t *inst);

/* pre-definitiion of event trigger functions */
static void on_trigger_Reset(csim_evt_t *evt);
static void on_trigger_Update(csim_evt_t *evt);

static void on_update_all(csim_inst_t *inst) {

    on_update_Reset(inst);
    on_update_Update(inst);
}

/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void tc16bit1_reset(csim_inst_t *inst) {
    tc16bit1_inst_t *tc16bit1_inst = (tc16bit1_inst_t *)inst;
    tc16bit1_inst->TCCR1A = 0;
    tc16bit1_inst->CLK = 0;
    tc16bit1_inst->OC1A = 0;
    tc16bit1_inst->ICR1L = 0;
    tc16bit1_inst->ICR1H = 0;
    tc16bit1_inst->TIMSK1 = 0;
    tc16bit1_inst->TCCR1B = 0;
    tc16bit1_inst->TCNT1L = 0;
    tc16bit1_inst->TIFR1 = 0;
    tc16bit1_inst->OCR1BH = 0;
    tc16bit1_inst->TCCR1C = 0;
    tc16bit1_inst->OCR1BL = 0;
    tc16bit1_inst->OCR1AL = 0;
    tc16bit1_inst->TCNT1H = 0;
    tc16bit1_inst->OCR1AH = 0;
}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void tc16bit1_construct(csim_inst_t *inst, csim_confs_t confs) {
    tc16bit1_inst_t *tc16bit1_inst = (tc16bit1_inst_t *)inst;
    tc16bit1_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void tc16bit1_destruct(csim_inst_t *inst) {}

/* TCCR1A register functions */

static void name_TCCR1A(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter Control Register A");
}

static void display_TCCR1A(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TCCR1A);
    ;
}

static csim_word_t read_TCCR1A(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1A;
}

static csim_word_t get_TCCR1A(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1A;
}

static void set_TCCR1A(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TCCR1A != val) {
        __inst->TCCR1A = val;
        on_update_all(inst);
    }
}

static void write_TCCR1A(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TCCR1A(inst, num, val);

    ;
    on_update_all(inst);
}

/* OC1A register functions */

static void name_OC1A(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Output Compare A");
}

static void display_OC1A(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->OC1A);
    ;
}

static csim_word_t read_OC1A(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OC1A;
}

static csim_word_t get_OC1A(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OC1A;
}

static void set_OC1A(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->OC1A != val) {
        __inst->OC1A = val;
        on_update_all(inst);
    }
}

static void write_OC1A(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_OC1A(inst, num, val);

    ;
    on_update_all(inst);
}

/* ICR1L register functions */

static void name_ICR1L(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Input Capture Register Low");
}

static void display_ICR1L(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->ICR1L);
    ;
}

static csim_word_t read_ICR1L(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->ICR1L;
}

static csim_word_t get_ICR1L(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->ICR1L;
}

static void set_ICR1L(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->ICR1L != val) {
        __inst->ICR1L = val;
        on_update_all(inst);
    }
}

static void write_ICR1L(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_ICR1L(inst, num, val);

    ;
    on_update_all(inst);
}

/* ICR1H register functions */

static void name_ICR1H(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Input Capture Register High");
}

static void display_ICR1H(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->ICR1H);
    ;
}

static csim_word_t read_ICR1H(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->ICR1H;
}

static csim_word_t get_ICR1H(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->ICR1H;
}

static void set_ICR1H(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->ICR1H != val) {
        __inst->ICR1H = val;
        on_update_all(inst);
    }
}

static void write_ICR1H(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_ICR1H(inst, num, val);

    ;
    on_update_all(inst);
}

/* TIMSK1 register functions */

static void name_TIMSK1(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter Interrupt Mask Register");
}

static void display_TIMSK1(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TIMSK1);
    ;
}

static csim_word_t read_TIMSK1(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TIMSK1;
}

static csim_word_t get_TIMSK1(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TIMSK1;
}

static void set_TIMSK1(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TIMSK1 != val) {
        __inst->TIMSK1 = val;
        on_update_all(inst);
    }
}

static void write_TIMSK1(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TIMSK1(inst, num, val);

    ;
    on_update_all(inst);
}

/* TCCR1B register functions */

static void name_TCCR1B(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter Control Register B");
}

static void display_TCCR1B(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TCCR1B);
    ;
}

static csim_word_t read_TCCR1B(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1B;
}

static csim_word_t get_TCCR1B(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1B;
}

static void set_TCCR1B(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TCCR1B != val) {
        __inst->TCCR1B = val;
        on_update_all(inst);
    }
}

static void write_TCCR1B(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TCCR1B(inst, num, val);

    ;
    on_update_all(inst);
}

/* TCNT1L register functions */

static void name_TCNT1L(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter ");
}

static void display_TCNT1L(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TCNT1L);
    ;
}

static csim_word_t read_TCNT1L(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCNT1L;
}

static csim_word_t get_TCNT1L(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCNT1L;
}

static void set_TCNT1L(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TCNT1L != val) {
        __inst->TCNT1L = val;
        on_update_all(inst);
    }
}

static void write_TCNT1L(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TCNT1L(inst, num, val);

    ;
    on_update_all(inst);
}

/* TIFR1 register functions */

static void name_TIFR1(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter Interrupt Flag Register");
}

static void display_TIFR1(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TIFR1);
    ;
}

static csim_word_t read_TIFR1(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TIFR1;
}

static csim_word_t get_TIFR1(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TIFR1;
}

static void set_TIFR1(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TIFR1 != val) {
        __inst->TIFR1 = val;
        on_update_all(inst);
    }
}

static void write_TIFR1(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TIFR1(inst, num, val);

    ;
    on_update_all(inst);
}

/* OCR1BH register functions */

static void name_OCR1BH(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Output Compare Register B High");
}

static void display_OCR1BH(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->OCR1BH);
    ;
}

static csim_word_t read_OCR1BH(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1BH;
}

static csim_word_t get_OCR1BH(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1BH;
}

static void set_OCR1BH(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->OCR1BH != val) {
        __inst->OCR1BH = val;
        on_update_all(inst);
    }
}

static void write_OCR1BH(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_OCR1BH(inst, num, val);

    ;
    on_update_all(inst);
}

/* TCCR1C register functions */

static void name_TCCR1C(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter Control Register C");
}

static void display_TCCR1C(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TCCR1C);
    ;
}

static csim_word_t read_TCCR1C(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1C;
}

static csim_word_t get_TCCR1C(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCCR1C;
}

static void set_TCCR1C(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TCCR1C != val) {
        __inst->TCCR1C = val;
        on_update_all(inst);
    }
}

static void write_TCCR1C(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TCCR1C(inst, num, val);

    ;
    on_update_all(inst);
}

/* OCR1BL register functions */

static void name_OCR1BL(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Output Compare Register B Low");
}

static void display_OCR1BL(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->OCR1BL);
    ;
}

static csim_word_t read_OCR1BL(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1BL;
}

static csim_word_t get_OCR1BL(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1BL;
}

static void set_OCR1BL(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->OCR1BL != val) {
        __inst->OCR1BL = val;
        on_update_all(inst);
    }
}

static void write_OCR1BL(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_OCR1BL(inst, num, val);

    ;
    on_update_all(inst);
}

/* OCR1AL register functions */

static void name_OCR1AL(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Output Compare Register A Low");
}

static void display_OCR1AL(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->OCR1AL);
    ;
}

static csim_word_t read_OCR1AL(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1AL;
}

static csim_word_t get_OCR1AL(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1AL;
}

static void set_OCR1AL(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->OCR1AL != val) {
        __inst->OCR1AL = val;
        on_update_all(inst);
    }
}

static void write_OCR1AL(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_OCR1AL(inst, num, val);

    ;
    on_update_all(inst);
}

/* TCNT1H register functions */

static void name_TCNT1H(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Timer/Counter ");
}

static void display_TCNT1H(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->TCNT1H);
    ;
}

static csim_word_t read_TCNT1H(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCNT1H;
}

static csim_word_t get_TCNT1H(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->TCNT1H;
}

static void set_TCNT1H(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->TCNT1H != val) {
        __inst->TCNT1H = val;
        on_update_all(inst);
    }
}

static void write_TCNT1H(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_TCNT1H(inst, num, val);

    ;
    on_update_all(inst);
}

/* OCR1AH register functions */

static void name_OCR1AH(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    __buffer += sprintf(__buffer, "Output Compare Register A High");
}

static void display_OCR1AH(csim_inst_t *inst, int num, char *__buffer, int size) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    snprintf(__buffer, size, "%d", __inst->OCR1AH);
    ;
}

static csim_word_t read_OCR1AH(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1AH;
}

static csim_word_t get_OCR1AH(csim_inst_t *inst, int num) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    return __inst->OCR1AH;
}

static void set_OCR1AH(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    if (__inst->OCR1AH != val) {
        __inst->OCR1AH = val;
        on_update_all(inst);
    }
}

static void write_OCR1AH(csim_inst_t *inst, int num, csim_word_t val) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;
    set_OCR1AH(inst, num, val);

    ;
    on_update_all(inst);
}

/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
    {"TCCR1A", // name
     0x80,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TCCR1A, display_TCCR1A, read_TCCR1A, write_TCCR1A, get_TCCR1A, set_TCCR1A},
    {
        "CLK",    // name
        0x1,      // offset
        0,        // size
        1,        // count
        0,        // stride
        0,        // flags
        CSIM_INT, // signal type
    },
    {"OC1A",   // name
     0x3,      // offset
     0,        // size
     1,        // count
     0,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_OC1A, display_OC1A, read_OC1A, write_OC1A, get_OC1A, set_OC1A},
    {"ICR1L",  // name
     0x86,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_ICR1L, display_ICR1L, read_ICR1L, write_ICR1L, get_ICR1L, set_ICR1L},
    {"ICR1H",  // name
     0x87,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_ICR1H, display_ICR1H, read_ICR1H, write_ICR1H, get_ICR1H, set_ICR1H},
    {"TIMSK1", // name
     0x6f,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TIMSK1, display_TIMSK1, read_TIMSK1, write_TIMSK1, get_TIMSK1, set_TIMSK1},
    {"TCCR1B", // name
     0x81,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TCCR1B, display_TCCR1B, read_TCCR1B, write_TCCR1B, get_TCCR1B, set_TCCR1B},
    {"TCNT1L", // name
     0x84,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TCNT1L, display_TCNT1L, read_TCNT1L, write_TCNT1L, get_TCNT1L, set_TCNT1L},
    {"TIFR1",  // name
     0x36,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TIFR1, display_TIFR1, read_TIFR1, write_TIFR1, get_TIFR1, set_TIFR1},
    {"OCR1BH", // name
     0x8b,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_OCR1BH, display_OCR1BH, read_OCR1BH, write_OCR1BH, get_OCR1BH, set_OCR1BH},
    {"TCCR1C", // name
     0x82,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TCCR1C, display_TCCR1C, read_TCCR1C, write_TCCR1C, get_TCCR1C, set_TCCR1C},
    {"OCR1BL", // name
     0x8a,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_OCR1BL, display_OCR1BL, read_OCR1BL, write_OCR1BL, get_OCR1BL, set_OCR1BL},
    {"OCR1AL", // name
     0x88,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_OCR1AL, display_OCR1AL, read_OCR1AL, write_OCR1AL, get_OCR1AL, set_OCR1AL},
    {"TCNT1H", // name
     0x85,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_TCNT1H, display_TCNT1H, read_TCNT1H, write_TCNT1H, get_TCNT1H, set_TCNT1H},
    {"OCR1AH", // name
     0x89,     // offset
     1,        // size
     1,        // count
     1,        // stride
     0,        // flags
     CSIM_INT, // signal type
     name_OCR1AH, display_OCR1AH, read_OCR1AH, write_OCR1AH, get_OCR1AH, set_OCR1AH},

};

/* predeclaration of port-functions */

/**
 * Array of ports.
 */
static csim_port_t ports[] = {

};

/*Reset event functions */

static void on_update_Reset(csim_inst_t *inst) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;

    csim_evt_t *Update = malloc(sizeof(csim_evt_t));
    Update->date = __now + 1;
    Update->inst = inst;
    Update->trigger = on_trigger_Update;
    csim_record_event(inst->board, Update);
}

static void on_trigger_Reset(csim_evt_t *evt) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)evt->inst;
    csim_inst_t *inst = evt->inst;
}

/*Update event functions */

static void on_update_Update(csim_inst_t *inst) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)inst;

    uint8_t __gliss_4_tcnt1;
    uint8_t __gliss_7_com1a;
    uint8_t __gliss_6_ocr1a;
    uint8_t __gliss_5_tcnt1;
    uint8_t __gliss_9_icr1;
    uint8_t __gliss_8_tcnt1;
    uint8_t __gliss_3_OCIE1A;
    uint32_t __gliss_2_prescaler;
    uint8_t __gliss_1_cs1;
    uint8_t __gliss_0_wgm;
    __gliss_0_wgm = (___MASK32(2, (_field8(_TCCR1B, 4, 3) << 2)) | _field8(_TCCR1A, 1, 0));
    __gliss_1_cs1 = _field8(_TCCR1B, 2, 0);
    __gliss_2_prescaler = 0;
    __gliss_3_OCIE1A = _bit8(_TIMSK1, 1);
    if ((((uint32_t)(__gliss_3_OCIE1A)) == 1)) {
        csim_evt_t *Update = malloc(sizeof(csim_evt_t));
        Update->inst = inst;
        Update->trigger = on_trigger_Update;
        csim_cancel_event(inst->board, Update);
    }
    switch (__gliss_1_cs1) {
    case 5:
        __gliss_2_prescaler = 1024LU;
        break;
    case 4:
        __gliss_2_prescaler = 256LU;
        break;
    case 3:
        __gliss_2_prescaler = 64;
        break;
    case 2:
        __gliss_2_prescaler = 8;
        break;
    case 1:
        __gliss_2_prescaler = 1;
        break;
    }
    switch (__gliss_0_wgm) {
    case 12:
        __gliss_8_tcnt1 = ((_TCNT1H << 8) | _TCNT1L);
        __gliss_9_icr1 = ((_ICR1H << 8) | _ICR1L);
        if ((__gliss_8_tcnt1 == __gliss_9_icr1)) {
            __gliss_8_tcnt1 = ((uint8_t)(0));
            _TCNT1H = ((uint8_t)(0));
            _TCNT1L = ((uint8_t)(0));
            _TIFR1 = _set_field8(_TIFR1, ((uint8_t)(1)), 0, 0);
        } else {
            __gliss_8_tcnt1 = ((uint8_t)((((uint32_t)(__gliss_8_tcnt1)) + 1)));
            _TCNT1H = (__gliss_8_tcnt1 >> 8);
            _TCNT1L = ((uint8_t)((((uint32_t)(__gliss_8_tcnt1)) & 255LU)));
        }
        break;
    case 4:
        __gliss_5_tcnt1 = ((_TCNT1H << 8) | _TCNT1L);
        __gliss_6_ocr1a = ((_OCR1AH << 8) | _OCR1AL);
        __gliss_7_com1a = _field8(_TCCR1A, 7, 6);
        switch (__gliss_7_com1a) {
        case 3:
            _OC1A = ((uint8_t)(1));
            break;
        case 2:
            _OC1A = ((uint8_t)(0));
            break;
        case 1:
            _OC1A = ___MASK32(1, ~_OC1A);
            break;
        }
        if ((__gliss_5_tcnt1 == __gliss_6_ocr1a)) {
            __gliss_5_tcnt1 = ((uint8_t)(0));
            _TCNT1H = ((uint8_t)(0));
            _TCNT1L = ((uint8_t)(0));
            _TIFR1 = _set_field8(_TIFR1, ((uint8_t)(1)), 0, 0);
        } else {
            __gliss_5_tcnt1 = ((uint8_t)((((uint32_t)(__gliss_5_tcnt1)) + 1)));
            _TCNT1H = (__gliss_5_tcnt1 >> 8);
            _TCNT1L = ((uint8_t)((((uint32_t)(__gliss_5_tcnt1)) & 255LU)));
        }
        break;
    case 0:
        __gliss_4_tcnt1 = ((_TCNT1H << 8) | _TCNT1L);
        if ((((uint32_t)(__gliss_4_tcnt1)) == 65535LU)) {
            __gliss_4_tcnt1 = ((uint8_t)(0));
            _TCNT1H = ((uint8_t)(0));
            _TCNT1L = ((uint8_t)(0));
            _TIFR1 = _set_field8(_TIFR1, ((uint8_t)(1)), 0, 0);
        } else {
            __gliss_4_tcnt1 = ((uint8_t)((((uint32_t)(__gliss_4_tcnt1)) + 1)));
            _TCNT1H = (__gliss_4_tcnt1 >> 8);
            _TCNT1L = ((uint8_t)((((uint32_t)(__gliss_4_tcnt1)) & 255LU)));
        }
        break;
    }
    csim_evt_t *Update = malloc(sizeof(csim_evt_t));
    Update->date = __now + __gliss_2_prescaler;
    Update->inst = inst;
    Update->trigger = on_trigger_Update;
    csim_record_event(inst->board, Update);
}

static void on_trigger_Update(csim_evt_t *evt) {
    tc16bit1_inst_t *__inst = (tc16bit1_inst_t *)evt->inst;
    csim_inst_t *inst = evt->inst;

    _CLK = ___MASK32(1, ~_CLK);
}

static int tc16bit1_display(char *buf, csim_iocomp_inst_t *inst) {
    char display[] = " ";
    // By default shows nothing, can be modified by changing the display var.
    return sprintf(buf, display);
}

static void tc16bit1_on_key(char key, csim_iocomp_inst_t *inst) {}

csim_iocomp_t tc16bit1_component = {{"tc16bit1", CSIM_IO,
                                     0,     // version
                                     regs,  // registers
                                     15,    // register count
                                     ports, // ports
                                     0,     // port count
                                     sizeof(tc16bit1_inst_t), tc16bit1_construct, tc16bit1_destruct,
                                     tc16bit1_reset},
                                    tc16bit1_display,
                                    tc16bit1_on_key};
