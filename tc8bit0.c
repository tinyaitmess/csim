/* Generated by gliss-csim (125/03/26 11:34:10) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _TCNT0	__inst->TCNT0
#	define _RAMP_STATE	__inst->RAMP_STATE
#	define _TIFR0	__inst->TIFR0
#	define _PRESCALER	__inst->PRESCALER
#	define _TCCR0A	__inst->TCCR0A
#	define _DELAY	__inst->DELAY
#	define _RAMP	__inst->RAMP
#	define _OCR0B	__inst->OCR0B
#	define _TCCR0B	__inst->TCCR0B
#	define _TIMSK0	__inst->TIMSK0
#	define _OCR0A	__inst->OCR0A

#	define OC0A_BASE	0
#	define _OC0A	__inst->OC0A
#	define OC0A_PORT	&ports[OC0A_BASE]
#		define OC0A_SET(x)	\
			{ \
				if(x != _OC0A) { \ 
					_OC0A = x; \
					csim_send_digital(inst, OC0A_PORT, _OC0A); \
				} \
			}
#	define OC0B_BASE	1
#	define _OC0B	__inst->OC0B
#	define OC0B_PORT	&ports[OC0B_BASE]
#		define OC0B_SET(x)	\
			{ \
				if(x != _OC0B) { \ 
					_OC0B = x; \
					csim_send_digital(inst, OC0B_PORT, _OC0B); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  tc8bit0_inst_t {
    csim_iocomp_t inst;
			uint8_t TCNT0;
			uint8_t RAMP_STATE;
			uint8_t TIFR0;
			uint16_t PRESCALER;
			uint8_t TCCR0A;
			uint16_t DELAY;
			uint8_t RAMP;
			uint8_t OCR0B;
			uint8_t TCCR0B;
			uint8_t TIMSK0;
			uint8_t OCR0A;

			uint8_t OC0A;
			uint8_t OC0B;
;
}  tc8bit0_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_OC0A(csim_inst_t *inst);
	static void on_update_OC0B(csim_inst_t *inst);


/* pre-definitiion of event update functions */
	static void on_update_ctc_mod(csim_inst_t *inst);
	static void on_update_todo_mod(csim_inst_t *inst);
	static void on_update_normal_mod(csim_inst_t *inst);
	static void on_update_fast_mod(csim_inst_t *inst);
	static void on_update_pwm_mod(csim_inst_t *inst);


/* pre-definitiion of event trigger functions */
	static void on_trigger_ctc_mod(csim_evt_t *evt);
	static void on_trigger_todo_mod(csim_evt_t *evt);
	static void on_trigger_normal_mod(csim_evt_t *evt);
	static void on_trigger_fast_mod(csim_evt_t *evt);
	static void on_trigger_pwm_mod(csim_evt_t *evt);


static void on_update_all(csim_inst_t *inst) {
		on_update_OC0A(inst);
		on_update_OC0B(inst);
	
		on_update_ctc_mod(inst);
		on_update_todo_mod(inst);
		on_update_normal_mod(inst);
		on_update_fast_mod(inst);
		on_update_pwm_mod(inst);
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  tc8bit0_reset(csim_inst_t *inst) {
    tc8bit0_inst_t * tc8bit0_inst = ( tc8bit0_inst_t *)inst;
	tc8bit0_inst -> TCNT0 = 0;
	tc8bit0_inst -> RAMP_STATE = 3;
	tc8bit0_inst -> TIFR0 = 0;
	tc8bit0_inst -> PRESCALER = 1;
	tc8bit0_inst -> TCCR0A = 0;
	tc8bit0_inst -> DELAY = 1000000;
	tc8bit0_inst -> RAMP = 1;
	tc8bit0_inst -> OCR0B = 0;
	tc8bit0_inst -> TCCR0B = 0;
	tc8bit0_inst -> TIMSK0 = 1;
	tc8bit0_inst -> OCR0A = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void tc8bit0_construct(csim_inst_t *inst, csim_confs_t confs) {
    tc8bit0_inst_t * tc8bit0_inst = ( tc8bit0_inst_t *)inst;
    tc8bit0_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void tc8bit0_destruct(csim_inst_t *inst) {
}


/* TCNT0 register functions */

static void name_TCNT0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Register");

}


static void display_TCNT0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCNT0);;
}

static csim_word_t read_TCNT0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCNT0;
}
 
static csim_word_t get_TCNT0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCNT0;
}
 
static void set_TCNT0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCNT0 != val) {
			__inst->TCNT0 = val;
			on_update_all(inst);
		}
	
}

static void write_TCNT0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCNT0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* RAMP_STATE register functions */

static void name_RAMP_STATE(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Ramp Outputs State (OC0B:OC0A)");

}


static void display_RAMP_STATE(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->RAMP_STATE);;
}

static csim_word_t read_RAMP_STATE(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->RAMP_STATE;
}
 
static csim_word_t get_RAMP_STATE(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->RAMP_STATE;
}
 
static void set_RAMP_STATE(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->RAMP_STATE != val) {
			__inst->RAMP_STATE = val;
			on_update_all(inst);
		}
	
}

static void write_RAMP_STATE(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_RAMP_STATE(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TIFR0 register functions */

static void name_TIFR0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Flag Register");

}


static void display_TIFR0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIFR0);;
}

static csim_word_t read_TIFR0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TIFR0;
}
 
static csim_word_t get_TIFR0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TIFR0;
}
 
static void set_TIFR0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TIFR0 != val) {
			__inst->TIFR0 = val;
			on_update_all(inst);
		}
	
}

static void write_TIFR0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TIFR0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCCR0A register functions */

static void name_TCCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register A");

}


static void display_TCCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR0A);;
}

static csim_word_t read_TCCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCCR0A;
}
 
static csim_word_t get_TCCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCCR0A;
}
 
static void set_TCCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCCR0A != val) {
			__inst->TCCR0A = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCCR0A(inst, num, val);

			switch(_field8(_TCCR0A, 1, 0)) {
	case 3:
		csim_evt_t *fast_mod = malloc(sizeof(csim_evt_t));
			fast_mod->date = __now +_DELAY;
			fast_mod->inst = inst;
			fast_mod->trigger = on_trigger_fast_mod;
			csim_record_event(inst -> board, fast_mod);
		break;
	case 2:
		csim_evt_t *ctc_mod = malloc(sizeof(csim_evt_t));
			ctc_mod->date = __now +_DELAY;
			ctc_mod->inst = inst;
			ctc_mod->trigger = on_trigger_ctc_mod;
			csim_record_event(inst -> board, ctc_mod);
		break;
	case 1:
		csim_evt_t *pwm_mod = malloc(sizeof(csim_evt_t));
			pwm_mod->date = __now +_DELAY;
			pwm_mod->inst = inst;
			pwm_mod->trigger = on_trigger_pwm_mod;
			csim_record_event(inst -> board, pwm_mod);
		break;
	case 0:
		csim_evt_t *normal_mod = malloc(sizeof(csim_evt_t));
			normal_mod->date = __now +_DELAY;
			normal_mod->inst = inst;
			normal_mod->trigger = on_trigger_normal_mod;
			csim_record_event(inst -> board, normal_mod);
		break;
	}
;
		on_update_all(inst);
	
}

/* RAMP register functions */

static void name_RAMP(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Ramp Direction (Up/Down)");

}


static void display_RAMP(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->RAMP);;
}

static csim_word_t read_RAMP(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->RAMP;
}
 
static csim_word_t get_RAMP(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->RAMP;
}
 
static void set_RAMP(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->RAMP != val) {
			__inst->RAMP = val;
			on_update_all(inst);
		}
	
}

static void write_RAMP(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_RAMP(inst, num, val);

		;
		on_update_all(inst);
	
}

/* OCR0B register functions */

static void name_OCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register B");

}


static void display_OCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR0B);;
}

static csim_word_t read_OCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->OCR0B;
}
 
static csim_word_t get_OCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->OCR0B;
}
 
static void set_OCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->OCR0B != val) {
			__inst->OCR0B = val;
			on_update_all(inst);
		}
	
}

static void write_OCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_OCR0B(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCCR0B register functions */

static void name_TCCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register B");

}


static void display_TCCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR0B);;
}

static csim_word_t read_TCCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCCR0B;
}
 
static csim_word_t get_TCCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCCR0B;
}
 
static void set_TCCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCCR0B != val) {
			__inst->TCCR0B = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCCR0B(inst, num, val);

			switch(_field8(_TCCR0B, 2, 0)) {
	case 7:
		_PRESCALER = ((uint16_t)(16));
		break;
	case 6:
		_PRESCALER = ((uint16_t)(4));
		break;
	case 5:
		_PRESCALER = ((uint16_t)(1024LU));
		break;
	case 4:
		_PRESCALER = ((uint16_t)(256LU));
		break;
	case 3:
		_PRESCALER = ((uint16_t)(64));
		break;
	case 2:
		_PRESCALER = ((uint16_t)(8));
		break;
	case 1:
		_PRESCALER = ((uint16_t)(1));
		break;
	case 0:
		_PRESCALER = ((uint16_t)(0));
		break;
	default:
		_PRESCALER = ((uint16_t)(1));
	}
	if((((uint32_t)(_PRESCALER)) == 0)) {
		_DELAY = ((uint16_t)(1));
	}
	else
		_DELAY = ((uint16_t)(((((uint32_t)(_PRESCALER)) * 1000000LU) / 16000000LU)));
;
		on_update_all(inst);
	
}

/* TIMSK0 register functions */

static void name_TIMSK0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Mask Register");

}


static void display_TIMSK0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIMSK0);;
}

static csim_word_t read_TIMSK0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TIMSK0;
}
 
static csim_word_t get_TIMSK0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TIMSK0;
}
 
static void set_TIMSK0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TIMSK0 != val) {
			__inst->TIMSK0 = val;
			on_update_all(inst);
		}
	
}

static void write_TIMSK0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TIMSK0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* OCR0A register functions */

static void name_OCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register A");

}


static void display_OCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR0A);;
}

static csim_word_t read_OCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->OCR0A;
}
 
static csim_word_t get_OCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->OCR0A;
}
 
static void set_OCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->OCR0A != val) {
			__inst->OCR0A = val;
			on_update_all(inst);
		}
	
}

static void write_OCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_OCR0A(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"TCNT0",		// name
		0x46,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCNT0,
		display_TCNT0,
		read_TCNT0,
		write_TCNT0,
		get_TCNT0,
		set_TCNT0
	},
	{
		"RAMP_STATE",		// name
		0x60,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_RAMP_STATE,
		display_RAMP_STATE,
		read_RAMP_STATE,
		write_RAMP_STATE,
		get_RAMP_STATE,
		set_RAMP_STATE
	},
	{
		"TIFR0",		// name
		0x35,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIFR0,
		display_TIFR0,
		read_TIFR0,
		write_TIFR0,
		get_TIFR0,
		set_TIFR0
	},
	{
		"PRESCALER",		// name
		0x51,		// offset
		2,		// size
		1,		// count
		2,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},
	{
		"TCCR0A",		// name
		0x44,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR0A,
		display_TCCR0A,
		read_TCCR0A,
		write_TCCR0A,
		get_TCCR0A,
		set_TCCR0A
	},
	{
		"DELAY",		// name
		0x50,		// offset
		2,		// size
		1,		// count
		2,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},
	{
		"RAMP",		// name
		0x52,		// offset
		0,		// size
		1,		// count
		0,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_RAMP,
		display_RAMP,
		read_RAMP,
		write_RAMP,
		get_RAMP,
		set_RAMP
	},
	{
		"OCR0B",		// name
		0x48,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR0B,
		display_OCR0B,
		read_OCR0B,
		write_OCR0B,
		get_OCR0B,
		set_OCR0B
	},
	{
		"TCCR0B",		// name
		0x45,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR0B,
		display_TCCR0B,
		read_TCCR0B,
		write_TCCR0B,
		get_TCCR0B,
		set_TCCR0B
	},
	{
		"TIMSK0",		// name
		0x6e,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIMSK0,
		display_TIMSK0,
		read_TIMSK0,
		write_TIMSK0,
		get_TIMSK0,
		set_TIMSK0
	},
	{
		"OCR0A",		// name
		0x47,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR0A,
		display_OCR0A,
		read_OCR0A,
		write_OCR0A,
		get_OCR0A,
		set_OCR0A
	},

};


/* predeclaration of port-functions */
static void on_input_OC0A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);
static void on_input_OC0B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
			{
				"OC0A",
				CSIM_DIGITAL,
				on_input_OC0A
			},
			{
				"OC0B",
				CSIM_DIGITAL,
				on_input_OC0B
			},

};


/* OC0A port functions */

static void on_input_OC0A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)port->inst;
	uint8_t OC0A = __inst->OC0A;
	int ____INDEX = port->port - (ports + OC0A_BASE);
	if (type == CSIM_DIGITAL)
		OC0A = val.digital;
	if (type == CSIM_ANALOG)
		OC0A = val.analog;
	if (type == CSIM_CLOCK)
		OC0A = val.clock;
	if (type == CSIM_SERIAL)
		OC0A = val.serial;
	
	
	

}

static void on_update_OC0A(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

}

/* OC0B port functions */

static void on_input_OC0B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)port->inst;
	uint8_t OC0B = __inst->OC0B;
	int ____INDEX = port->port - (ports + OC0B_BASE);
	if (type == CSIM_DIGITAL)
		OC0B = val.digital;
	if (type == CSIM_ANALOG)
		OC0B = val.analog;
	if (type == CSIM_CLOCK)
		OC0B = val.clock;
	if (type == CSIM_SERIAL)
		OC0B = val.serial;
	
	
	

}

static void on_update_OC0B(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

}



/*ctc_mod event functions */

static void on_update_ctc_mod(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

	
}

static void on_trigger_ctc_mod(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		if((_TCNT0 == _OCR0A)) {
		_TIFR0 = ((uint8_t)((((uint32_t)(_TIFR0)) | 2)));
		_TCNT0 = ((uint8_t)(0));
		OC0A_SET(((uint8_t)(1)));
		_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(1)), 0, 0);
	}
	else
		_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
	csim_evt_t *ctc_mod = malloc(sizeof(csim_evt_t));
			ctc_mod->date = __now +_DELAY;
			ctc_mod->inst = inst;
			ctc_mod->trigger = on_trigger_ctc_mod;
			csim_record_event(inst -> board, ctc_mod);

}

/*todo_mod event functions */

static void on_update_todo_mod(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

	
}

static void on_trigger_todo_mod(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		_TIFR0 = ((uint8_t)((((uint32_t)(_TIFR0)) | 2)));

}

/*normal_mod event functions */

static void on_update_normal_mod(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

	
}

static void on_trigger_normal_mod(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		if((((uint32_t)(_TCNT0)) == 255LU)) {
		_TIFR0 = ((uint8_t)((((uint32_t)(_TIFR0)) | 1)));
		_TCNT0 = ((uint8_t)(0));
		if((((uint32_t)(_RAMP)) == 1)) {
			OC0A_SET(((uint8_t)(1)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(1)), 0, 0);
		}
		else {
			OC0A_SET(((uint8_t)(0)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(0)), 0, 0);
		}
	}
	else
		_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
	csim_evt_t *normal_mod = malloc(sizeof(csim_evt_t));
			normal_mod->date = __now +_DELAY;
			normal_mod->inst = inst;
			normal_mod->trigger = on_trigger_normal_mod;
			csim_record_event(inst -> board, normal_mod);

}

/*fast_mod event functions */

static void on_update_fast_mod(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

	
}

static void on_trigger_fast_mod(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
	if((_TCNT0 == _OCR0A)) {
		_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 1, 1);
		OC0A_SET(((uint8_t)(0)));
		_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(0)), 0, 0);
	}
	if((_TCNT0 == _OCR0B)) {
		_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 2, 2);
		OC0B_SET(((uint8_t)(0)));
		_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(0)), 1, 1);
	}
	if((((uint32_t)(_TCNT0)) == 255LU)) {
		_TCNT0 = ((uint8_t)(0));
		OC0A_SET(((uint8_t)(1)));
		OC0B_SET(((uint8_t)(1)));
		_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(3)), 1, 0);
	}
	csim_evt_t *fast_mod = malloc(sizeof(csim_evt_t));
			fast_mod->date = __now +_DELAY;
			fast_mod->inst = inst;
			fast_mod->trigger = on_trigger_fast_mod;
			csim_record_event(inst -> board, fast_mod);

}

/*pwm_mod event functions */

static void on_update_pwm_mod(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

	
}

static void on_trigger_pwm_mod(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		if((((uint32_t)(_RAMP)) == 1)) {
		_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
		if((_TCNT0 == _OCR0A)) {
			_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 1, 1);
			OC0A_SET(((uint8_t)(0)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(0)), 0, 0);
		}
		if((((uint32_t)(_TCNT0)) == 255LU)) {
			_RAMP = ((uint8_t)(0));
			OC0B_SET(((uint8_t)(1)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(1)), 1, 1);
		}
	}
	else {
		_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) - 1)));
		if((_TCNT0 == _OCR0B)) {
			_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 2, 2);
			OC0B_SET(((uint8_t)(0)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(0)), 1, 1);
		}
		if((((uint32_t)(_TCNT0)) == 0)) {
			_RAMP = ((uint8_t)(1));
			OC0A_SET(((uint8_t)(1)));
			OC0B_SET(((uint8_t)(1)));
			_RAMP_STATE = _set_field8(_RAMP_STATE, ((uint8_t)(3)), 1, 0);
		}
	}
	csim_evt_t *pwm_mod = malloc(sizeof(csim_evt_t));
			pwm_mod->date = __now +_DELAY;
			pwm_mod->inst = inst;
			pwm_mod->trigger = on_trigger_pwm_mod;
			csim_record_event(inst -> board, pwm_mod);

}




static int tc8bit0_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void tc8bit0_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  tc8bit0_component = {
	{
    "tc8bit0",
    CSIM_IO,
    0,					// version
    regs,				// registers
    11 ,	// register count
    ports,				// ports
    2,		// port count
    sizeof(tc8bit0_inst_t),
    tc8bit0_construct,
    tc8bit0_destruct,
    tc8bit0_reset
	},
	tc8bit0_display,
	tc8bit0_on_key
};

