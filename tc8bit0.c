/* Generated by gliss-csim (125/03/24 12:45:17) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _TCNT0	__inst->TCNT0
#	define _CLK	__inst->CLK
#	define _TIFR0	__inst->TIFR0
#	define _TCCR0A	__inst->TCCR0A
#	define _OCR0B	__inst->OCR0B
#	define _TCCR0B	__inst->TCCR0B
#	define _TIMSK0	__inst->TIMSK0
#	define _OCR0A	__inst->OCR0A

#	define OC0A_BASE	0
#	define _OC0A	__inst->OC0A
#	define OC0A_PORT	&ports[OC0A_BASE]
#		define OC0A_SET(x)	\
			{ \
				if(x != _OC0A) { \ 
					_OC0A = x; \
					csim_send_digital(inst, OC0A_PORT, _OC0A); \
				} \
			}
#	define OC0B_BASE	1
#	define _OC0B	__inst->OC0B
#	define OC0B_PORT	&ports[OC0B_BASE]
#		define OC0B_SET(x)	\
			{ \
				if(x != _OC0B) { \ 
					_OC0B = x; \
					csim_send_digital(inst, OC0B_PORT, _OC0B); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  tc8bit0_inst_t {
    csim_iocomp_t inst;
			uint8_t TCNT0;
			uint8_t CLK;
			uint8_t TIFR0;
			uint8_t TCCR0A;
			uint8_t OCR0B;
			uint8_t TCCR0B;
			uint8_t TIMSK0;
			uint8_t OCR0A;

			uint8_t OC0A;
			uint8_t OC0B;
;
}  tc8bit0_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_OC0A(csim_inst_t *inst);
	static void on_update_OC0B(csim_inst_t *inst);


/* pre-definitiion of event update functions */
	static void on_update_Reset(csim_inst_t *inst);
	static void on_update_Update(csim_inst_t *inst);


/* pre-definitiion of event trigger functions */
	static void on_trigger_Reset(csim_evt_t *evt);
	static void on_trigger_Update(csim_evt_t *evt);


static void on_update_all(csim_inst_t *inst) {
		on_update_OC0A(inst);
		on_update_OC0B(inst);
	
		on_update_Reset(inst);
		on_update_Update(inst);
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  tc8bit0_reset(csim_inst_t *inst) {
    tc8bit0_inst_t * tc8bit0_inst = ( tc8bit0_inst_t *)inst;
	tc8bit0_inst -> TCNT0 = 0;
	tc8bit0_inst -> CLK = 0;
	tc8bit0_inst -> TIFR0 = 0;
	tc8bit0_inst -> TCCR0A = 0;
	tc8bit0_inst -> OCR0B = 0;
	tc8bit0_inst -> TCCR0B = 3;
	tc8bit0_inst -> TIMSK0 = 1;
	tc8bit0_inst -> OCR0A = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void tc8bit0_construct(csim_inst_t *inst, csim_confs_t confs) {
    tc8bit0_inst_t * tc8bit0_inst = ( tc8bit0_inst_t *)inst;
    tc8bit0_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void tc8bit0_destruct(csim_inst_t *inst) {
}


/* TCNT0 register functions */

static void name_TCNT0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Register");

}


static void display_TCNT0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCNT0);;
}

static csim_word_t read_TCNT0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCNT0;
}
 
static csim_word_t get_TCNT0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCNT0;
}
 
static void set_TCNT0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCNT0 != val) {
			__inst->TCNT0 = val;
			on_update_all(inst);
		}
	
}

static void write_TCNT0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCNT0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TIFR0 register functions */

static void name_TIFR0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Flag Register");

}


static void display_TIFR0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIFR0);;
}

static csim_word_t read_TIFR0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TIFR0;
}
 
static csim_word_t get_TIFR0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TIFR0;
}
 
static void set_TIFR0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TIFR0 != val) {
			__inst->TIFR0 = val;
			on_update_all(inst);
		}
	
}

static void write_TIFR0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TIFR0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCCR0A register functions */

static void name_TCCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register A");

}


static void display_TCCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR0A);;
}

static csim_word_t read_TCCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCCR0A;
}
 
static csim_word_t get_TCCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCCR0A;
}
 
static void set_TCCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCCR0A != val) {
			__inst->TCCR0A = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCCR0A(inst, num, val);

		;
		on_update_all(inst);
	
}

/* OCR0B register functions */

static void name_OCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register B");

}


static void display_OCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR0B);;
}

static csim_word_t read_OCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->OCR0B;
}
 
static csim_word_t get_OCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->OCR0B;
}
 
static void set_OCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->OCR0B != val) {
			__inst->OCR0B = val;
			on_update_all(inst);
		}
	
}

static void write_OCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_OCR0B(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCCR0B register functions */

static void name_TCCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register B");

}


static void display_TCCR0B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR0B);;
}

static csim_word_t read_TCCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TCCR0B;
}
 
static csim_word_t get_TCCR0B(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TCCR0B;
}
 
static void set_TCCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TCCR0B != val) {
			__inst->TCCR0B = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR0B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TCCR0B(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TIMSK0 register functions */

static void name_TIMSK0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Mask Register");

}


static void display_TIMSK0(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIMSK0);;
}

static csim_word_t read_TIMSK0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->TIMSK0;
}
 
static csim_word_t get_TIMSK0(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->TIMSK0;
}
 
static void set_TIMSK0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->TIMSK0 != val) {
			__inst->TIMSK0 = val;
			on_update_all(inst);
		}
	
}

static void write_TIMSK0(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_TIMSK0(inst, num, val);

		;
		on_update_all(inst);
	
}

/* OCR0A register functions */

static void name_OCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register A");

}


static void display_OCR0A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR0A);;
}

static csim_word_t read_OCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
				return __inst->OCR0A;
}
 
static csim_word_t get_OCR0A(csim_inst_t *inst, int num) {
		tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
			return __inst->OCR0A;
}
 
static void set_OCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
		if(__inst->OCR0A != val) {
			__inst->OCR0A = val;
			on_update_all(inst);
		}
	
}

static void write_OCR0A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;
	set_OCR0A(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"TCNT0",		// name
		0x46,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCNT0,
		display_TCNT0,
		read_TCNT0,
		write_TCNT0,
		get_TCNT0,
		set_TCNT0
	},
	{
		"CLK",		// name
		0x1,		// offset
		0,		// size
		1,		// count
		0,		// stride
		0,				// flags
		CSIM_INT,		// signal type
	},
	{
		"TIFR0",		// name
		0x35,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIFR0,
		display_TIFR0,
		read_TIFR0,
		write_TIFR0,
		get_TIFR0,
		set_TIFR0
	},
	{
		"TCCR0A",		// name
		0x44,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR0A,
		display_TCCR0A,
		read_TCCR0A,
		write_TCCR0A,
		get_TCCR0A,
		set_TCCR0A
	},
	{
		"OCR0B",		// name
		0x48,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR0B,
		display_OCR0B,
		read_OCR0B,
		write_OCR0B,
		get_OCR0B,
		set_OCR0B
	},
	{
		"TCCR0B",		// name
		0x45,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR0B,
		display_TCCR0B,
		read_TCCR0B,
		write_TCCR0B,
		get_TCCR0B,
		set_TCCR0B
	},
	{
		"TIMSK0",		// name
		0x6e,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIMSK0,
		display_TIMSK0,
		read_TIMSK0,
		write_TIMSK0,
		get_TIMSK0,
		set_TIMSK0
	},
	{
		"OCR0A",		// name
		0x47,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR0A,
		display_OCR0A,
		read_OCR0A,
		write_OCR0A,
		get_OCR0A,
		set_OCR0A
	},

};


/* predeclaration of port-functions */
static void on_input_OC0A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);
static void on_input_OC0B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
			{
				"OC0A",
				CSIM_DIGITAL,
				on_input_OC0A
			},
			{
				"OC0B",
				CSIM_DIGITAL,
				on_input_OC0B
			},

};


/* OC0A port functions */

static void on_input_OC0A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)port->inst;
	uint8_t OC0A = __inst->OC0A;
	int ____INDEX = port->port - (ports + OC0A_BASE);
	if (type == CSIM_DIGITAL)
		OC0A = val.digital;
	if (type == CSIM_ANALOG)
		OC0A = val.analog;
	if (type == CSIM_CLOCK)
		OC0A = val.clock;
	if (type == CSIM_SERIAL)
		OC0A = val.serial;
	
	
	

}

static void on_update_OC0A(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

}

/* OC0B port functions */

static void on_input_OC0B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)port->inst;
	uint8_t OC0B = __inst->OC0B;
	int ____INDEX = port->port - (ports + OC0B_BASE);
	if (type == CSIM_DIGITAL)
		OC0B = val.digital;
	if (type == CSIM_ANALOG)
		OC0B = val.analog;
	if (type == CSIM_CLOCK)
		OC0B = val.clock;
	if (type == CSIM_SERIAL)
		OC0B = val.serial;
	
	
	

}

static void on_update_OC0B(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

}



/*Reset event functions */

static void on_update_Reset(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

		csim_evt_t *Update = malloc(sizeof(csim_evt_t));
			Update->date = __now +1;
			Update->inst = inst;
			Update->trigger = on_trigger_Update;
			csim_record_event(inst -> board, Update);

}

static void on_trigger_Reset(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

	
}

/*Update event functions */

static void on_update_Update(csim_inst_t *inst) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)inst;

		uint8_t __gliss_1_wgm1;
	uint8_t __gliss_0_wgm0;
	__gliss_0_wgm0 = _bit8(_TCCR0A, 0);
	__gliss_1_wgm1 = _bit8(_TCCR0A, 1);
	if(((((uint32_t)(__gliss_1_wgm1)) == 1) && (((uint32_t)(__gliss_0_wgm0)) == 0))) {
		if((_TCNT0 == _OCR0A)) {
			_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 1, 1);
			_TCNT0 = ((uint8_t)(0));
			OC0A_SET(_bit8(_TIFR0, 1));
		}
		else
			_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
	}
	else {
		if((((uint32_t)(_TCNT0)) == 255LU)) {
			_TIFR0 = _set_field8(_TIFR0, ((uint8_t)(1)), 0, 0);
			_TCNT0 = ((uint8_t)(0));
			OC0A_SET(_bit8(_TIFR0, 0));
		}
		else
			_TCNT0 = ((uint8_t)((((uint32_t)(_TCNT0)) + 1)));
	}
	csim_evt_t *Update = malloc(sizeof(csim_evt_t));
			Update->date = __now +1;
			Update->inst = inst;
			Update->trigger = on_trigger_Update;
			csim_record_event(inst -> board, Update);

}

static void on_trigger_Update(csim_evt_t *evt) {
	tc8bit0_inst_t *__inst = (tc8bit0_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		_CLK = ___MASK32(1, ~_CLK);

}




static int tc8bit0_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void tc8bit0_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  tc8bit0_component = {
	{
    "tc8bit0",
    CSIM_IO,
    0,					// version
    regs,				// registers
    8 ,	// register count
    ports,				// ports
    2,		// port count
    sizeof(tc8bit0_inst_t),
    tc8bit0_construct,
    tc8bit0_destruct,
    tc8bit0_reset
	},
	tc8bit0_display,
	tc8bit0_on_key
};

