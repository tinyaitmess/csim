/* Generated by gliss-csim (125/03/24 14:29:30) copyright (c) 2024 IRIT - UPS */

#include <stdio.h>
#include <stdlib.h>
#include <csim.h>
#include "csim-rt.h"

#define ____COMP_NUM		(inst->number)
#	define _nombreDeClk	__inst->nombreDeClk
#	define _TIMSK2	__inst->TIMSK2
#	define _TCCR2A	__inst->TCCR2A
#	define _TCCR2B	__inst->TCCR2B
#	define _OCR2B	__inst->OCR2B
#	define _OCR2A	__inst->OCR2A
#	define _TIFR2	__inst->TIFR2
#	define _TCNT2	__inst->TCNT2

#	define OC2B_BASE	0
#	define _OC2B	__inst->OC2B
#	define OC2B_PORT	&ports[OC2B_BASE]
#		define OC2B_SET(x)	\
			{ \
				if(x != _OC2B) { \ 
					_OC2B = x; \
					csim_send_digital(inst, OC2B_PORT, _OC2B); \
				} \
			}
#	define OC2A_BASE	1
#	define _OC2A	__inst->OC2A
#	define OC2A_PORT	&ports[OC2A_BASE]
#		define OC2A_SET(x)	\
			{ \
				if(x != _OC2A) { \ 
					_OC2A = x; \
					csim_send_digital(inst, OC2A_PORT, _OC2A); \
				} \
			}


#define __now inst->board->date



/**
 * Instance definition.
 */
typedef struct  tc8bit2_inst_t {
    csim_iocomp_t inst;
			uint16_t nombreDeClk;
			uint8_t TIMSK2;
			uint8_t TCCR2A;
			uint8_t TCCR2B;
			uint8_t OCR2B;
			uint8_t OCR2A;
			uint8_t TIFR2;
			uint8_t TCNT2;

			uint8_t OC2B;
			uint8_t OC2A;
;
}  tc8bit2_inst_t;


/* pre-definitiion of port update functions */
	static void on_update_OC2B(csim_inst_t *inst);
	static void on_update_OC2A(csim_inst_t *inst);


/* pre-definitiion of event update functions */
	static void on_update_clk(csim_inst_t *inst);


/* pre-definitiion of event trigger functions */
	static void on_trigger_clk(csim_evt_t *evt);


static void on_update_all(csim_inst_t *inst) {
		on_update_OC2B(inst);
		on_update_OC2A(inst);
	
		on_update_clk(inst);
	
}


/**
 * Reset the instance.
 * @param inst	Instance to reset.
 */
static void  tc8bit2_reset(csim_inst_t *inst) {
    tc8bit2_inst_t * tc8bit2_inst = ( tc8bit2_inst_t *)inst;
	tc8bit2_inst -> nombreDeClk = 0;
	tc8bit2_inst -> TIMSK2 = 0;
	tc8bit2_inst -> TCCR2A = 0;
	tc8bit2_inst -> TCCR2B = 0;
	tc8bit2_inst -> OCR2B = 0;
	tc8bit2_inst -> OCR2A = 0;
	tc8bit2_inst -> TIFR2 = 0;
	tc8bit2_inst -> TCNT2 = 0;

}

/**
 * Construct an instance.
 * @param inst	Instance to construct.
 */
static void tc8bit2_construct(csim_inst_t *inst, csim_confs_t confs) {
    tc8bit2_inst_t * tc8bit2_inst = ( tc8bit2_inst_t *)inst;
    tc8bit2_reset(inst);
}

/**
 * Destruct the instance.
 * @param inst	Instance to destruct.
 */
static void tc8bit2_destruct(csim_inst_t *inst) {
}


/* nombreDeClk register functions */

static void name_nombreDeClk(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "logical counter");

}


static void display_nombreDeClk(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->nombreDeClk);;
}

static csim_word_t read_nombreDeClk(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->nombreDeClk;
}
 
static csim_word_t get_nombreDeClk(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->nombreDeClk;
}
 
static void set_nombreDeClk(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->nombreDeClk != val) {
			__inst->nombreDeClk = val;
			on_update_all(inst);
		}
	
}

static void write_nombreDeClk(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_nombreDeClk(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TIMSK2 register functions */

static void name_TIMSK2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Mask Register");

}


static void display_TIMSK2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIMSK2);;
}

static csim_word_t read_TIMSK2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->TIMSK2;
}
 
static csim_word_t get_TIMSK2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->TIMSK2;
}
 
static void set_TIMSK2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->TIMSK2 != val) {
			__inst->TIMSK2 = val;
			on_update_all(inst);
		}
	
}

static void write_TIMSK2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_TIMSK2(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCCR2A register functions */

static void name_TCCR2A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register A");

}


static void display_TCCR2A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR2A);;
}

static csim_word_t read_TCCR2A(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->TCCR2A;
}
 
static csim_word_t get_TCCR2A(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->TCCR2A;
}
 
static void set_TCCR2A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->TCCR2A != val) {
			__inst->TCCR2A = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR2A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_TCCR2A(inst, num, val);

			csim_evt_t *clk = malloc(sizeof(csim_evt_t));
			clk->date = __now +5;
			clk->inst = inst;
			clk->trigger = on_trigger_clk;
			csim_record_event(inst -> board, clk);
;
		on_update_all(inst);
	
}

/* TCCR2B register functions */

static void name_TCCR2B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Control Register B");

}


static void display_TCCR2B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCCR2B);;
}

static csim_word_t read_TCCR2B(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->TCCR2B;
}
 
static csim_word_t get_TCCR2B(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->TCCR2B;
}
 
static void set_TCCR2B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->TCCR2B != val) {
			__inst->TCCR2B = val;
			on_update_all(inst);
		}
	
}

static void write_TCCR2B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_TCCR2B(inst, num, val);

			csim_evt_t *clk = malloc(sizeof(csim_evt_t));
			clk->date = __now +5;
			clk->inst = inst;
			clk->trigger = on_trigger_clk;
			csim_record_event(inst -> board, clk);
;
		on_update_all(inst);
	
}

/* OCR2B register functions */

static void name_OCR2B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register B");

}


static void display_OCR2B(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR2B);;
}

static csim_word_t read_OCR2B(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->OCR2B;
}
 
static csim_word_t get_OCR2B(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->OCR2B;
}
 
static void set_OCR2B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->OCR2B != val) {
			__inst->OCR2B = val;
			on_update_all(inst);
		}
	
}

static void write_OCR2B(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_OCR2B(inst, num, val);

		;
		on_update_all(inst);
	
}

/* OCR2A register functions */

static void name_OCR2A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Output Compare Register A");

}


static void display_OCR2A(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->OCR2A);;
}

static csim_word_t read_OCR2A(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->OCR2A;
}
 
static csim_word_t get_OCR2A(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->OCR2A;
}
 
static void set_OCR2A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->OCR2A != val) {
			__inst->OCR2A = val;
			on_update_all(inst);
		}
	
}

static void write_OCR2A(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_OCR2A(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TIFR2 register functions */

static void name_TIFR2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Interrupt Flag Register");

}


static void display_TIFR2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TIFR2);;
}

static csim_word_t read_TIFR2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->TIFR2;
}
 
static csim_word_t get_TIFR2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->TIFR2;
}
 
static void set_TIFR2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->TIFR2 != val) {
			__inst->TIFR2 = val;
			on_update_all(inst);
		}
	
}

static void write_TIFR2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_TIFR2(inst, num, val);

		;
		on_update_all(inst);
	
}

/* TCNT2 register functions */

static void name_TCNT2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		__buffer += sprintf(__buffer, "Timer/Counter Register");

}


static void display_TCNT2(csim_inst_t *inst, int num, char *__buffer, int size) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	snprintf(__buffer, size, "%d", __inst->TCNT2);;
}

static csim_word_t read_TCNT2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
				return __inst->TCNT2;
}
 
static csim_word_t get_TCNT2(csim_inst_t *inst, int num) {
		tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
			return __inst->TCNT2;
}
 
static void set_TCNT2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
		if(__inst->TCNT2 != val) {
			__inst->TCNT2 = val;
			on_update_all(inst);
		}
	
}

static void write_TCNT2(csim_inst_t *inst, int num, csim_word_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;
	set_TCNT2(inst, num, val);

		;
		on_update_all(inst);
	
}




/**
 * Array of registers.
 */
static csim_reg_t regs[] = {
	{
		"nombreDeClk",		// name
		0x1,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_nombreDeClk,
		display_nombreDeClk,
		read_nombreDeClk,
		write_nombreDeClk,
		get_nombreDeClk,
		set_nombreDeClk
	},
	{
		"TIMSK2",		// name
		0x70,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIMSK2,
		display_TIMSK2,
		read_TIMSK2,
		write_TIMSK2,
		get_TIMSK2,
		set_TIMSK2
	},
	{
		"TCCR2A",		// name
		0xb0,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR2A,
		display_TCCR2A,
		read_TCCR2A,
		write_TCCR2A,
		get_TCCR2A,
		set_TCCR2A
	},
	{
		"TCCR2B",		// name
		0xb1,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCCR2B,
		display_TCCR2B,
		read_TCCR2B,
		write_TCCR2B,
		get_TCCR2B,
		set_TCCR2B
	},
	{
		"OCR2B",		// name
		0xb4,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR2B,
		display_OCR2B,
		read_OCR2B,
		write_OCR2B,
		get_OCR2B,
		set_OCR2B
	},
	{
		"OCR2A",		// name
		0xb3,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_OCR2A,
		display_OCR2A,
		read_OCR2A,
		write_OCR2A,
		get_OCR2A,
		set_OCR2A
	},
	{
		"TIFR2",		// name
		0x37,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TIFR2,
		display_TIFR2,
		read_TIFR2,
		write_TIFR2,
		get_TIFR2,
		set_TIFR2
	},
	{
		"TCNT2",		// name
		0xb2,		// offset
		1,		// size
		1,		// count
		1,		// stride
		0,				// flags
		CSIM_INT,		// signal type
		name_TCNT2,
		display_TCNT2,
		read_TCNT2,
		write_TCNT2,
		get_TCNT2,
		set_TCNT2
	},

};


/* predeclaration of port-functions */
static void on_input_OC2B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);
static void on_input_OC2A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val);



/**
 * Array of ports.
 */
static csim_port_t ports[] = {
			{
				"OC2B",
				CSIM_DIGITAL,
				on_input_OC2B
			},
			{
				"OC2A",
				CSIM_DIGITAL,
				on_input_OC2A
			},

};


/* OC2B port functions */

static void on_input_OC2B(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)port->inst;
	uint8_t OC2B = __inst->OC2B;
	int ____INDEX = port->port - (ports + OC2B_BASE);
	if (type == CSIM_DIGITAL)
		OC2B = val.digital;
	if (type == CSIM_ANALOG)
		OC2B = val.analog;
	if (type == CSIM_CLOCK)
		OC2B = val.clock;
	if (type == CSIM_SERIAL)
		OC2B = val.serial;
	
	
	

}

static void on_update_OC2B(csim_inst_t *inst) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;

}

/* OC2A port functions */

static void on_input_OC2A(csim_port_inst_t *port, csim_value_type_t type, csim_value_t val) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)port->inst;
	uint8_t OC2A = __inst->OC2A;
	int ____INDEX = port->port - (ports + OC2A_BASE);
	if (type == CSIM_DIGITAL)
		OC2A = val.digital;
	if (type == CSIM_ANALOG)
		OC2A = val.analog;
	if (type == CSIM_CLOCK)
		OC2A = val.clock;
	if (type == CSIM_SERIAL)
		OC2A = val.serial;
	
	
	

}

static void on_update_OC2A(csim_inst_t *inst) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;

}



/*clk event functions */

static void on_update_clk(csim_inst_t *inst) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)inst;

	
}

static void on_trigger_clk(csim_evt_t *evt) {
	tc8bit2_inst_t *__inst = (tc8bit2_inst_t *)evt->inst;
	csim_inst_t *inst = evt->inst;

		if((((uint32_t)(_bit8(_TCNT2, 0))) == 255LU)) {
		_TCNT2 = _set_field8(_TCNT2, ((uint8_t)(0)), 0, 0);
	}
	else
		_TCNT2 = _set_field8(_TCNT2, ((uint8_t)((((uint32_t)(_bit8(_TCNT2, 0))) + 1))), 0, 0);
	if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 0) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 0)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 1))) {
		_NOMBREDECLK = ((uint16_t)(1));
	}
	else {
		if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 0) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 1)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 0))) {
			_NOMBREDECLK = ((uint16_t)(8));
		}
		else {
			if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 0) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 1)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 1))) {
				_NOMBREDECLK = ((uint16_t)(32));
			}
			else {
				if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 1) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 0)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 0))) {
					_NOMBREDECLK = ((uint16_t)(64));
				}
				else {
					if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 1) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 0)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 1))) {
						_NOMBREDECLK = ((uint16_t)(128));
					}
					else {
						if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 1) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 1)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 0))) {
							_NOMBREDECLK = ((uint16_t)(256LU));
						}
						else {
							if((((((uint32_t)(_bit8(_TCCR2B, 2))) == 1) && (((uint32_t)(_bit8(_TCCR2B, 1))) == 1)) && (((uint32_t)(_bit8(_TCCR2B, 0))) == 1))) {
								_NOMBREDECLK = ((uint16_t)(1024LU));
							}
						}
					}
				}
			}
		}
	}
	csim_evt_t *clk = malloc(sizeof(csim_evt_t));
			clk->date = __now +_NOMBREDECLK;
			clk->inst = inst;
			clk->trigger = on_trigger_clk;
			csim_record_event(inst -> board, clk);

}




static int tc8bit2_display(char *buf, csim_iocomp_inst_t *inst) {
	char display[] = " ";
	// By default shows nothing, can be modified by changing the display var.
	return sprintf(buf,display);
}

static void tc8bit2_on_key(char key, csim_iocomp_inst_t *inst) {
}


csim_iocomp_t  tc8bit2_component = {
	{
    "tc8bit2",
    CSIM_IO,
    0,					// version
    regs,				// registers
    8 ,	// register count
    ports,				// ports
    2,		// port count
    sizeof(tc8bit2_inst_t),
    tc8bit2_construct,
    tc8bit2_destruct,
    tc8bit2_reset
	},
	tc8bit2_display,
	tc8bit2_on_key
};

